//  Async / await

// There is a special syntax to work with promises in more comfortable fashion, called async/await. it is suprisingly easy to understand and use.


async function f() {
    return 1;
  }

  //e word “async” before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.

// For instance, this function returns a resolved promise with the result of 1; let’s test it:


async function f() {
    return 10;
  }
  
  f().then(result => console.log(result)); // 1

  //.. we could explicitly return a promise, which would be the same

  async function f1() {
    return Promise.resolve(1);
  }
  
  f1().then(res => console.log(res)); // 1


//   So async ensures that the function returns a promise and wraps non promise in it. simple enough right but not only tha t. there is another keyword await the works only inside the async functions and its pretty cool.


// Await

// works only inside async functions

// let val = await promise;


// /The keyword await makes JavaScript wait until that promise settles and returns its result.


async function f2() {

    let promise = new Promise((resolve, reject) => {
      setTimeout(() => resolve("done!"), 1000)
    });
  
    let resulty = await promise; // wait until the promise resolves (*)
  
    console.log(resulty); // "done!"
  }
  
  f2();


  /*The function execution “pauses” at the line (*) and resumes when the promise settles, with result becoming its result. So the code above shows “done!” in one second.

Let’s emphasize: await literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.

It’s just a more elegant syntax of getting the promise result than promise.then. And, it’s easier to read and write. */




// can't use await in regular functions

// f we try to use await in a non-async function, there would be a syntax error:

// function f() {
//     let promise = Promise.resolve(1);
//     let result = await promise; // Syntax error
//   }
//   We may get this error if we forget to put async before a function. As stated earlier, await only works inside an async function.



async function showAvatar() {

    // read our JSON
    let response = await fetch('/article/promise-chaining/user.json');
    let user = await response.json();
  
    // read github user
    let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
    let githubUser = await githubResponse.json();
  
    // show the avatar
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);
  
    // wait 3 seconds
    await new Promise((resolve, reject) => setTimeout(resolve, 3000));
  
    img.remove();
  
    return githubUser;
  }
  
  showAvatar();



//   ?------------------------------------------ Error handling________________________-------------------------

// If a promise resolves normally, then await promise returns the result. But in the case of a rejection, it throws the error, just as if there were a throw statement at that line.

// is code:

async function f() {
  await Promise.reject(new Error("Whoops!"));
}
// …is the same as this:

async function f() {
  throw new Error("Whoops!");
}

// In real situations, the promise may take some time before it rejects. In that case there will be a delay before await throws an error.


// If we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:

async function f() {
  let response = await fetch('http://no-such-url');
}

// f() becomes a rejected promise
f().catch(alert); // TypeError: failed to fetch // (*)
// If we forget to add .catch there, then we get an unhandled promise error (viewable in the console). We can catch such errors using a global unhandledrejection event handler as described in the chapter Error handling with promises.


/*async/await and promise.then/catch
When we use async/await, we rarely need .then, because await handles the waiting for us. And we can use a regular try..catch instead of .catch. That’s usually (but not always) more convenient.

But at the top level of the code, when we’re outside any async function, we’re syntactically unable to use await, so it’s a normal practice to add .then/catch to handle the final result or falling-through error, like in the line (*) of the example above.

async/await works well with Promise.all
When we need to wait for multiple promises, we can wrap them in Promise.all and then await:

// wait for the array of results
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
  ...
]);
In the case of an error, it propagates as usual, from the failed promise to Promise.all, and then becomes an exception that we can catch using try..catch around the call. */